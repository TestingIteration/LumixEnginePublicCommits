// Generated by meta.cpp

#include "animation/animation_module.h"
#include "audio/audio_module.h"
#include "core/geometry.h"
#include "editor/asset_browser.h"
#include "engine/core.h"
#include "gui/gui_module.h"
#include "gui/gui_system.h"
#include "lua/lua_script_system.h"
#include "navigation/navigation_module.h"
#include "physics/physics_module.h"
#include "renderer/editor/scene_view.h"
#include "renderer/model.h"
#include "renderer/render_module.h"

namespace Lumix {
int PropertyAnimator_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		LuaWrapper::push(L, module->isPropertyAnimatorEnabled(entity));
	else if (equalStrings(prop_name, "looped"))
		LuaWrapper::push(L, module->getPropertyAnimatorLooped(entity));
	else if (equalStrings(prop_name, "animation"))
		LuaWrapper::push(L, module->getPropertyAnimatorAnimation(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int PropertyAnimator_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		module->enablePropertyAnimator(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "looped"))
		module->setPropertyAnimatorLooped(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "animation"))
		module->setPropertyAnimatorAnimation(entity, LuaWrapper::checkArg<Path>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Animator_applySet(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	auto idx = LuaWrapper::checkArg<u32>(L, 2);
	module->applyAnimatorSet(entity, idx);
	return 0;
}

int Animator_setBoolInput(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	auto input_idx = LuaWrapper::checkArg<u32>(L, 2);
	auto value = LuaWrapper::checkArg<bool>(L, 3);
	module->setAnimatorInput(entity, input_idx, value);
	return 0;
}

int Animator_setFloatInput(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	auto input_idx = LuaWrapper::checkArg<u32>(L, 2);
	auto value = LuaWrapper::checkArg<float>(L, 3);
	module->setAnimatorInput(entity, input_idx, value);
	return 0;
}

int Animator_setVec3Input(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	auto input_idx = LuaWrapper::checkArg<u32>(L, 2);
	auto value = LuaWrapper::checkArg<Vec3>(L, 3);
	module->setAnimatorInput(entity, input_idx, value);
	return 0;
}

int Animator_getInputIndex(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	auto name = LuaWrapper::checkArg<const char*>(L, 2);
	LuaWrapper::push(L, module->getAnimatorInputIndex(entity, name));
	return 1;
}

int Animator_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "source"))
		LuaWrapper::push(L, module->getAnimatorSource(entity));
	else if (equalStrings(prop_name, "use_root_motion"))
		LuaWrapper::push(L, module->getAnimatorUseRootMotion(entity));
	else if (equalStrings(prop_name, "default_set"))
		LuaWrapper::push(L, module->getAnimatorDefaultSet(entity));
	else if (equalStrings(prop_name, "applySet")) {
		lua_pushcfunction(L, Animator_applySet, "Animator_applyAnimatorSet");
	} else if (equalStrings(prop_name, "setBoolInput")) {
		lua_pushcfunction(L, Animator_setBoolInput, "Animator_setAnimatorInput");
	} else if (equalStrings(prop_name, "setFloatInput")) {
		lua_pushcfunction(L, Animator_setFloatInput, "Animator_setAnimatorInput");
	} else if (equalStrings(prop_name, "setVec3Input")) {
		lua_pushcfunction(L, Animator_setVec3Input, "Animator_setAnimatorInput");
	} else if (equalStrings(prop_name, "getInputIndex")) {
		lua_pushcfunction(L, Animator_getInputIndex, "Animator_getAnimatorInputIndex");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Animator_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "source"))
		module->setAnimatorSource(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "use_root_motion"))
		module->setAnimatorUseRootMotion(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "default_set"))
		module->setAnimatorDefaultSet(entity, LuaWrapper::checkArg<u32>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Animable_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "animation"))
		LuaWrapper::push(L, module->getAnimableAnimation(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Animable_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AnimationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "animation"))
		module->setAnimableAnimation(entity, LuaWrapper::checkArg<Path>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {
int AudioModule_play(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	AudioModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto entity = LuaWrapper::checkArg<EntityRef>(L, 2);
	auto clip = LuaWrapper::checkArg<Path>(L, 3);
	auto is_3d = LuaWrapper::checkArg<bool>(L, 4);
	LuaWrapper::push(L, module->play(entity, clip, is_3d));
	return 1;
}

int AudioModule_setMasterVolume(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	AudioModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto volume = LuaWrapper::checkArg<float>(L, 2);
	module->setMasterVolume(volume);
	return 0;
}

int AudioModule_stop(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	AudioModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto sound_id = LuaWrapper::checkArg<SoundHandle>(L, 2);
	module->stop(sound_id);
	return 0;
}

int AudioModule_isEnd(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	AudioModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto sound_id = LuaWrapper::checkArg<SoundHandle>(L, 2);
	LuaWrapper::push(L, module->isEnd(sound_id));
	return 1;
}

int AudioModule_setFrequency(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	AudioModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto sound_id = LuaWrapper::checkArg<SoundHandle>(L, 2);
	auto frequency_hz = LuaWrapper::checkArg<u32>(L, 3);
	module->setFrequency(sound_id, frequency_hz);
	return 0;
}

int AudioModule_setVolume(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	AudioModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto sound_id = LuaWrapper::checkArg<SoundHandle>(L, 2);
	auto volume = LuaWrapper::checkArg<float>(L, 3);
	module->setVolume(sound_id, volume);
	return 0;
}

int AudioModule_setEcho(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	AudioModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto sound_id = LuaWrapper::checkArg<SoundHandle>(L, 2);
	auto wet_dry_mix = LuaWrapper::checkArg<float>(L, 3);
	auto feedback = LuaWrapper::checkArg<float>(L, 4);
	auto left_delay = LuaWrapper::checkArg<float>(L, 5);
	auto right_delay = LuaWrapper::checkArg<float>(L, 6);
	module->setEcho(sound_id, wet_dry_mix, feedback, left_delay, right_delay);
	return 0;
}

int EchoZone_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "radius"))
		LuaWrapper::push(L, module->getEchoZone(entity).radius);
	else if (equalStrings(prop_name, "delay"))
		LuaWrapper::push(L, module->getEchoZone(entity).delay);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int EchoZone_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "radius"))
		module->getEchoZone(entity).radius = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "delay"))
		module->getEchoZone(entity).delay = LuaWrapper::checkArg<float>(L, 3);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int ChorusZone_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "radius"))
		LuaWrapper::push(L, module->getChorusZone(entity).radius);
	else if (equalStrings(prop_name, "delay"))
		LuaWrapper::push(L, module->getChorusZone(entity).delay);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int ChorusZone_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "radius"))
		module->getChorusZone(entity).radius = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "delay"))
		module->getChorusZone(entity).delay = LuaWrapper::checkArg<float>(L, 3);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Listener_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Listener_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int AmbientSound_pause(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	module->pauseAmbientSound(entity);
	return 0;
}

int AmbientSound_resume(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	module->resumeAmbientSound(entity);
	return 0;
}

int AmbientSound_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "clip"))
		LuaWrapper::push(L, module->getAmbientSoundClip(entity));
	else if (equalStrings(prop_name, "3d"))
		LuaWrapper::push(L, module->isAmbientSound3D(entity));
	else if (equalStrings(prop_name, "pause")) {
		lua_pushcfunction(L, AmbientSound_pause, "AmbientSound_pauseAmbientSound");
	} else if (equalStrings(prop_name, "resume")) {
		lua_pushcfunction(L, AmbientSound_resume, "AmbientSound_resumeAmbientSound");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int AmbientSound_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (AudioModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "clip"))
		module->setAmbientSoundClip(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "3d"))
		module->setAmbientSound3D(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {
int Spline_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (CoreModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Spline_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (CoreModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Signal_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (CoreModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Signal_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (CoreModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {
int GUIModule_getRectAt(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	GUIModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto pos = LuaWrapper::checkArg<Vec2>(L, 2);
	LuaWrapper::push(L, module->getRectAt(pos));
	return 1;
}

int GUIModule_isOver(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	GUIModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto pos = LuaWrapper::checkArg<Vec2>(L, 2);
	auto e = LuaWrapper::checkArg<EntityRef>(L, 3);
	LuaWrapper::push(L, module->isOver(pos, e));
	return 1;
}

int GUIModule_getSystemPtr(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	GUIModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	LuaWrapper::pushObject(L, module->getSystemPtr(), "GUISystem");
	return 1;
}

int Canvas_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "is_3d"))
		LuaWrapper::push(L, module->getCanvas(entity).is_3d);
	else if (equalStrings(prop_name, "orient_to_camera"))
		LuaWrapper::push(L, module->getCanvas(entity).orient_to_camera);
	else if (equalStrings(prop_name, "virtual_size"))
		LuaWrapper::push(L, module->getCanvas(entity).virtual_size);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Canvas_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "is_3d"))
		module->getCanvas(entity).is_3d = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "orient_to_camera"))
		module->getCanvas(entity).orient_to_camera = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "virtual_size"))
		module->getCanvas(entity).virtual_size = LuaWrapper::checkArg<Vec2>(L, 3);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int RenderTarget_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int RenderTarget_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int InputField_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int InputField_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Rect_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		LuaWrapper::push(L, module->isRectEnabled(entity));
	else if (equalStrings(prop_name, "clip_content"))
		LuaWrapper::push(L, module->getRectClip(entity));
	else if (equalStrings(prop_name, "left_points"))
		LuaWrapper::push(L, module->getRectLeftPoints(entity));
	else if (equalStrings(prop_name, "left_relative"))
		LuaWrapper::push(L, module->getRectLeftRelative(entity));
	else if (equalStrings(prop_name, "right_points"))
		LuaWrapper::push(L, module->getRectRightPoints(entity));
	else if (equalStrings(prop_name, "right_relative"))
		LuaWrapper::push(L, module->getRectRightRelative(entity));
	else if (equalStrings(prop_name, "top_points"))
		LuaWrapper::push(L, module->getRectTopPoints(entity));
	else if (equalStrings(prop_name, "top_relative"))
		LuaWrapper::push(L, module->getRectTopRelative(entity));
	else if (equalStrings(prop_name, "bottom_points"))
		LuaWrapper::push(L, module->getRectBottomPoints(entity));
	else if (equalStrings(prop_name, "bottom_relative"))
		LuaWrapper::push(L, module->getRectBottomRelative(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Rect_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		module->enableRect(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "clip_content"))
		module->setRectClip(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "left_points"))
		module->setRectLeftPoints(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "left_relative"))
		module->setRectLeftRelative(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "right_points"))
		module->setRectRightPoints(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "right_relative"))
		module->setRectRightRelative(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "top_points"))
		module->setRectTopPoints(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "top_relative"))
		module->setRectTopRelative(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "bottom_points"))
		module->setRectBottomPoints(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "bottom_relative"))
		module->setRectBottomRelative(entity, LuaWrapper::checkArg<float>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Button_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "hovered_color"))
		LuaWrapper::push(L, module->getButtonHoveredColorRGBA(entity));
	else if (equalStrings(prop_name, "hovered_cursor"))
		LuaWrapper::push(L, (i32)module->getButtonHoveredCursor(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Button_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "hovered_color"))
		module->setButtonHoveredColorRGBA(entity, LuaWrapper::checkArg<Vec4>(L, 3));
	else if (equalStrings(prop_name, "hovered_cursor"))
		module->setButtonHoveredCursor(entity, (os::CursorType)LuaWrapper::checkArg<i32>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Image_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		LuaWrapper::push(L, module->isImageEnabled(entity));
	else if (equalStrings(prop_name, "color"))
		LuaWrapper::push(L, module->getImageColorRGBA(entity));
	else if (equalStrings(prop_name, "sprite"))
		LuaWrapper::push(L, module->getImageSprite(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Image_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		module->enableImage(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "color"))
		module->setImageColorRGBA(entity, LuaWrapper::checkArg<Vec4>(L, 3));
	else if (equalStrings(prop_name, "sprite"))
		module->setImageSprite(entity, LuaWrapper::checkArg<Path>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Text_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "font_size"))
		LuaWrapper::push(L, module->getTextFontSize(entity));
	else if (equalStrings(prop_name, "color"))
		LuaWrapper::push(L, module->getTextColorRGBA(entity));
	else if (equalStrings(prop_name, "font"))
		LuaWrapper::push(L, module->getTextFontPath(entity));
	else if (equalStrings(prop_name, "horizontal_align"))
		LuaWrapper::push(L, (i32)module->getTextHAlign(entity));
	else if (equalStrings(prop_name, "vertical_align"))
		LuaWrapper::push(L, (i32)module->getTextVAlign(entity));
	else if (equalStrings(prop_name, "text"))
		LuaWrapper::push(L, module->getText(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Text_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (GUIModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "font_size"))
		module->setTextFontSize(entity, LuaWrapper::checkArg<int>(L, 3));
	else if (equalStrings(prop_name, "color"))
		module->setTextColorRGBA(entity, LuaWrapper::checkArg<Vec4>(L, 3));
	else if (equalStrings(prop_name, "font"))
		module->setTextFontPath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "horizontal_align"))
		module->setTextHAlign(entity, (TextHAlign)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "vertical_align"))
		module->setTextVAlign(entity, (TextVAlign)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "text"))
		module->setText(entity, LuaWrapper::checkArg<const char*>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {
int Script_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (LuaScriptModule*)imodule;
	if (lua_isnumber(L, 2)) return lua_push_script_env(L, entity, module);
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "scripts")) {
		using GetterModule = LuaScriptModule;
		auto getter = [](lua_State* L) -> int {
			LuaWrapper::checkTableArg(L, 1); // self
			auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
			EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
			if (lua_type(L, 2) == LUA_TSTRING) {
				auto adder = [](lua_State* L) -> int {
					auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
					EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
					module->addScript(entity, module->getScriptCount(entity));
					return 0;
				};

				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				if (equalStrings(prop_name, "add")) {
					LuaWrapper::push(L, module);
					LuaWrapper::push(L, entity.index);
					lua_pushcclosure(L, adder, "adder", 2);
					return 1;
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
			}

			auto getter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "enabled")) {
					LuaWrapper::push(L, module->isScriptEnabled(entity, index));
				} else if (equalStrings(prop_name, "path")) {
					LuaWrapper::push(L, module->getScriptPath(entity, index));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
				return 1;
			};

			auto setter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "enabled")) {
					module->enableScript(entity, index, LuaWrapper::checkArg<bool>(L, 3));
				} else if (equalStrings(prop_name, "path")) {
					module->setScriptPath(entity, index, LuaWrapper::checkArg<Path>(L, 3));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %ss", prop_name);
				}
				return 0;
			};

			i32 index = LuaWrapper::checkArg<i32>(L, 2) - 1;
			i32 num_elements = module->getScriptCount(entity);
			if (index >= num_elements) {
				lua_pushnil(L);
				return 1;
			}

			lua_newtable(L);
			lua_newtable(L);

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, getter, "getter", 3);
			lua_setfield(L, -2, "__index");

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, setter, "setter", 3);
			lua_setfield(L, -2, "__newindex");

			lua_setmetatable(L, -2);
			return 1;
		};

		lua_newtable(L); // {}
		lua_newtable(L); // {}, metatable
		LuaWrapper::push(L, module);
		LuaWrapper::push(L, entity.index);
		lua_pushcclosure(L, getter, "getter", 2);
		lua_setfield(L, -2, "__index"); // {}, mt
		lua_setmetatable(L, -2);		// {}
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Script_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (LuaScriptModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int InlineScript_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (LuaScriptModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "code"))
		LuaWrapper::push(L, module->getInlineScriptCode(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int InlineScript_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (LuaScriptModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "code"))
		module->setInlineScriptCode(entity, LuaWrapper::checkArg<const char*>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {
int Zone_load(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	LuaWrapper::push(L, module->loadZone(entity));
	return 1;
}

int Zone_drawNavmesh(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	auto pos = LuaWrapper::checkArg<DVec3>(L, 2);
	auto inner_boundaries = LuaWrapper::checkArg<bool>(L, 3);
	auto outer_boundaries = LuaWrapper::checkArg<bool>(L, 4);
	auto portals = LuaWrapper::checkArg<bool>(L, 5);
	module->debugDrawNavmesh(entity, pos, inner_boundaries, outer_boundaries, portals);
	return 0;
}

int Zone_drawCompactHeightfield(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	module->debugDrawCompactHeightfield(entity);
	return 0;
}

int Zone_drawHeightfield(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	module->debugDrawHeightfield(entity);
	return 0;
}

int Zone_drawContours(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	module->debugDrawContours(entity);
	return 0;
}

int Zone_generateNavmesh(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	LuaWrapper::push(L, module->generateNavmesh(entity));
	return 1;
}

int Zone_saveZone(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	LuaWrapper::push(L, module->saveZone(entity));
	return 1;
}

int Zone_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "extents"))
		LuaWrapper::push(L, module->getZone(entity).extents);
	else if (equalStrings(prop_name, "cell_size"))
		LuaWrapper::push(L, module->getZone(entity).cell_size);
	else if (equalStrings(prop_name, "cell_height"))
		LuaWrapper::push(L, module->getZone(entity).cell_height);
	else if (equalStrings(prop_name, "walkable_slope_angle"))
		LuaWrapper::push(L, module->getZone(entity).walkable_slope_angle);
	else if (equalStrings(prop_name, "agent_height"))
		LuaWrapper::push(L, module->getZone(entity).agent_height);
	else if (equalStrings(prop_name, "agent_radius"))
		LuaWrapper::push(L, module->getZone(entity).agent_radius);
	else if (equalStrings(prop_name, "max_climb"))
		LuaWrapper::push(L, module->getZone(entity).max_climb);
	else if (equalStrings(prop_name, "autoload"))
		LuaWrapper::push(L, module->getZoneAutoload(entity));
	else if (equalStrings(prop_name, "detailed"))
		LuaWrapper::push(L, module->getZoneDetailed(entity));
	else if (equalStrings(prop_name, "load")) {
		lua_pushcfunction(L, Zone_load, "Zone_loadZone");
	} else if (equalStrings(prop_name, "drawNavmesh")) {
		lua_pushcfunction(L, Zone_drawNavmesh, "Zone_debugDrawNavmesh");
	} else if (equalStrings(prop_name, "drawCompactHeightfield")) {
		lua_pushcfunction(L, Zone_drawCompactHeightfield, "Zone_debugDrawCompactHeightfield");
	} else if (equalStrings(prop_name, "drawHeightfield")) {
		lua_pushcfunction(L, Zone_drawHeightfield, "Zone_debugDrawHeightfield");
	} else if (equalStrings(prop_name, "drawContours")) {
		lua_pushcfunction(L, Zone_drawContours, "Zone_debugDrawContours");
	} else if (equalStrings(prop_name, "generateNavmesh")) {
		lua_pushcfunction(L, Zone_generateNavmesh, "Zone_generateNavmesh");
	} else if (equalStrings(prop_name, "saveZone")) {
		lua_pushcfunction(L, Zone_saveZone, "Zone_saveZone");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Zone_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "extents"))
		module->getZone(entity).extents = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "cell_size"))
		module->getZone(entity).cell_size = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "cell_height"))
		module->getZone(entity).cell_height = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "walkable_slope_angle"))
		module->getZone(entity).walkable_slope_angle = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "agent_height"))
		module->getZone(entity).agent_height = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "agent_radius"))
		module->getZone(entity).agent_radius = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "max_climb"))
		module->getZone(entity).max_climb = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "autoload"))
		module->setZoneAutoload(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "detailed"))
		module->setZoneDetailed(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Agent_navigate(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	auto dest = LuaWrapper::checkArg<DVec3>(L, 2);
	auto speed = LuaWrapper::checkArg<float>(L, 3);
	auto stop_distance = LuaWrapper::checkArg<float>(L, 4);
	LuaWrapper::push(L, module->navigate(entity, dest, speed, stop_distance));
	return 1;
}

int Agent_cancelNavigation(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	module->cancelNavigation(entity);
	return 0;
}

int Agent_drawPath(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	auto include_polygons = LuaWrapper::checkArg<bool>(L, 2);
	module->debugDrawPath(entity, include_polygons);
	return 0;
}

int Agent_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "radius"))
		LuaWrapper::push(L, module->getAgentRadius(entity));
	else if (equalStrings(prop_name, "height"))
		LuaWrapper::push(L, module->getAgentHeight(entity));
	else if (equalStrings(prop_name, "move_entity"))
		LuaWrapper::push(L, module->getAgentMoveEntity(entity));
	else if (equalStrings(prop_name, "speed"))
		LuaWrapper::push(L, module->getAgentSpeed(entity));
	else if (equalStrings(prop_name, "navigate")) {
		lua_pushcfunction(L, Agent_navigate, "Agent_navigate");
	} else if (equalStrings(prop_name, "cancelNavigation")) {
		lua_pushcfunction(L, Agent_cancelNavigation, "Agent_cancelNavigation");
	} else if (equalStrings(prop_name, "drawPath")) {
		lua_pushcfunction(L, Agent_drawPath, "Agent_debugDrawPath");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Agent_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (NavigationModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "radius"))
		module->setAgentRadius(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "height"))
		module->setAgentHeight(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "move_entity"))
		module->setAgentMoveEntity(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {
int PhysicsModule_raycast(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	PhysicsModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto origin = LuaWrapper::checkArg<Vec3>(L, 2);
	auto dir = LuaWrapper::checkArg<Vec3>(L, 3);
	auto distance = LuaWrapper::checkArg<float>(L, 4);
	auto ignore_entity = LuaWrapper::checkArg<EntityPtr>(L, 5);
	LuaWrapper::push(L, module->raycast(origin, dir, distance, ignore_entity));
	return 1;
}

int PhysicsModule_setGravity(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	PhysicsModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto gravity = LuaWrapper::checkArg<Vec3>(L, 2);
	module->setGravity(gravity);
	return 0;
}

int Heightfield_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "heightmap"))
		LuaWrapper::push(L, module->getHeightfieldSource(entity));
	else if (equalStrings(prop_name, "xz_scale"))
		LuaWrapper::push(L, module->getHeightfieldXZScale(entity));
	else if (equalStrings(prop_name, "yscale"))
		LuaWrapper::push(L, module->getHeightfieldYScale(entity));
	else if (equalStrings(prop_name, "layer"))
		LuaWrapper::push(L, module->getHeightfieldLayer(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Heightfield_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "heightmap"))
		module->setHeightfieldSource(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "xz_scale"))
		module->setHeightfieldXZScale(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "yscale"))
		module->setHeightfieldYScale(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "layer"))
		module->setHeightfieldLayer(entity, LuaWrapper::checkArg<u32>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int D6Joint_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "xmotion"))
		LuaWrapper::push(L, (i32)module->getD6JointXMotion(entity));
	else if (equalStrings(prop_name, "ymotion"))
		LuaWrapper::push(L, (i32)module->getD6JointYMotion(entity));
	else if (equalStrings(prop_name, "zmotion"))
		LuaWrapper::push(L, (i32)module->getD6JointZMotion(entity));
	else if (equalStrings(prop_name, "swing_1"))
		LuaWrapper::push(L, (i32)module->getD6JointSwing1Motion(entity));
	else if (equalStrings(prop_name, "swing_2"))
		LuaWrapper::push(L, (i32)module->getD6JointSwing2Motion(entity));
	else if (equalStrings(prop_name, "twist"))
		LuaWrapper::push(L, (i32)module->getD6JointTwistMotion(entity));
	else if (equalStrings(prop_name, "linear_limit"))
		LuaWrapper::push(L, module->getD6JointLinearLimit(entity));
	else if (equalStrings(prop_name, "twist_limit"))
		LuaWrapper::push(L, module->getD6JointTwistLimit(entity));
	else if (equalStrings(prop_name, "swing_limit"))
		LuaWrapper::push(L, module->getD6JointSwingLimit(entity));
	else if (equalStrings(prop_name, "damping"))
		LuaWrapper::push(L, module->getD6JointDamping(entity));
	else if (equalStrings(prop_name, "stiffness"))
		LuaWrapper::push(L, module->getD6JointStiffness(entity));
	else if (equalStrings(prop_name, "restitution"))
		LuaWrapper::push(L, module->getD6JointRestitution(entity));
	else if (equalStrings(prop_name, "connected_body"))
		LuaWrapper::push(L, module->getD6JointConnectedBody(entity));
	else if (equalStrings(prop_name, "axis_position"))
		LuaWrapper::push(L, module->getD6JointAxisPosition(entity));
	else if (equalStrings(prop_name, "axis_direction"))
		LuaWrapper::push(L, module->getD6JointAxisDirection(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int D6Joint_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "xmotion"))
		module->setD6JointXMotion(entity, (PhysicsModule::D6Motion)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "ymotion"))
		module->setD6JointYMotion(entity, (PhysicsModule::D6Motion)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "zmotion"))
		module->setD6JointZMotion(entity, (PhysicsModule::D6Motion)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "swing_1"))
		module->setD6JointSwing1Motion(entity, (PhysicsModule::D6Motion)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "swing_2"))
		module->setD6JointSwing2Motion(entity, (PhysicsModule::D6Motion)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "twist"))
		module->setD6JointTwistMotion(entity, (PhysicsModule::D6Motion)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "linear_limit"))
		module->setD6JointLinearLimit(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "twist_limit"))
		module->setD6JointTwistLimit(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else if (equalStrings(prop_name, "swing_limit"))
		module->setD6JointSwingLimit(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else if (equalStrings(prop_name, "damping"))
		module->setD6JointDamping(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "stiffness"))
		module->setD6JointStiffness(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "restitution"))
		module->setD6JointRestitution(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "connected_body"))
		module->setD6JointConnectedBody(entity, LuaWrapper::checkArg<EntityPtr>(L, 3));
	else if (equalStrings(prop_name, "axis_position"))
		module->setD6JointAxisPosition(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "axis_direction"))
		module->setD6JointAxisDirection(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int DistanceJoint_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "connected_body"))
		LuaWrapper::push(L, module->getDistanceJointConnectedBody(entity));
	else if (equalStrings(prop_name, "axis_position"))
		LuaWrapper::push(L, module->getDistanceJointAxisPosition(entity));
	else if (equalStrings(prop_name, "damping"))
		LuaWrapper::push(L, module->getDistanceJointDamping(entity));
	else if (equalStrings(prop_name, "stiffness"))
		LuaWrapper::push(L, module->getDistanceJointStiffness(entity));
	else if (equalStrings(prop_name, "tolerance"))
		LuaWrapper::push(L, module->getDistanceJointTolerance(entity));
	else if (equalStrings(prop_name, "limits"))
		LuaWrapper::push(L, module->getDistanceJointLimits(entity));
	else if (equalStrings(prop_name, "linear_force"))
		LuaWrapper::push(L, module->getDistanceJointLinearForce(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int DistanceJoint_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "connected_body"))
		module->setDistanceJointConnectedBody(entity, LuaWrapper::checkArg<EntityPtr>(L, 3));
	else if (equalStrings(prop_name, "axis_position"))
		module->setDistanceJointAxisPosition(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "damping"))
		module->setDistanceJointDamping(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "stiffness"))
		module->setDistanceJointStiffness(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "tolerance"))
		module->setDistanceJointTolerance(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "limits"))
		module->setDistanceJointLimits(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int HingeJoint_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "connected_body"))
		LuaWrapper::push(L, module->getHingeJointConnectedBody(entity));
	else if (equalStrings(prop_name, "axis_position"))
		LuaWrapper::push(L, module->getHingeJointAxisPosition(entity));
	else if (equalStrings(prop_name, "axis_direction"))
		LuaWrapper::push(L, module->getHingeJointAxisDirection(entity));
	else if (equalStrings(prop_name, "damping"))
		LuaWrapper::push(L, module->getHingeJointDamping(entity));
	else if (equalStrings(prop_name, "stiffness"))
		LuaWrapper::push(L, module->getHingeJointStiffness(entity));
	else if (equalStrings(prop_name, "use_limit"))
		LuaWrapper::push(L, module->getHingeJointUseLimit(entity));
	else if (equalStrings(prop_name, "limit"))
		LuaWrapper::push(L, module->getHingeJointLimit(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int HingeJoint_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "connected_body"))
		module->setHingeJointConnectedBody(entity, LuaWrapper::checkArg<EntityPtr>(L, 3));
	else if (equalStrings(prop_name, "axis_position"))
		module->setHingeJointAxisPosition(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "axis_direction"))
		module->setHingeJointAxisDirection(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "damping"))
		module->setHingeJointDamping(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "stiffness"))
		module->setHingeJointStiffness(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "use_limit"))
		module->setHingeJointUseLimit(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "limit"))
		module->setHingeJointLimit(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int SphericalJoint_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "connected_body"))
		LuaWrapper::push(L, module->getSphericalJointConnectedBody(entity));
	else if (equalStrings(prop_name, "axis_position"))
		LuaWrapper::push(L, module->getSphericalJointAxisPosition(entity));
	else if (equalStrings(prop_name, "axis_direction"))
		LuaWrapper::push(L, module->getSphericalJointAxisDirection(entity));
	else if (equalStrings(prop_name, "use_limit"))
		LuaWrapper::push(L, module->getSphericalJointUseLimit(entity));
	else if (equalStrings(prop_name, "limit"))
		LuaWrapper::push(L, module->getSphericalJointLimit(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int SphericalJoint_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "connected_body"))
		module->setSphericalJointConnectedBody(entity, LuaWrapper::checkArg<EntityPtr>(L, 3));
	else if (equalStrings(prop_name, "axis_position"))
		module->setSphericalJointAxisPosition(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "axis_direction"))
		module->setSphericalJointAxisDirection(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "use_limit"))
		module->setSphericalJointUseLimit(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "limit"))
		module->setSphericalJointLimit(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Controller_getGravitySpeed(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	LuaWrapper::push(L, module->getGravitySpeed(entity));
	return 1;
}

int Controller_move(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	auto v = LuaWrapper::checkArg<Vec3>(L, 2);
	module->moveController(entity, v);
	return 0;
}

int Controller_isCollisionDown(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	LuaWrapper::push(L, module->isControllerCollisionDown(entity));
	return 1;
}

int Controller_resize(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	auto height = LuaWrapper::checkArg<float>(L, 2);
	module->resizeController(entity, height);
	return 0;
}

int Controller_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "layer"))
		LuaWrapper::push(L, module->getControllerLayer(entity));
	else if (equalStrings(prop_name, "radius"))
		LuaWrapper::push(L, module->getControllerRadius(entity));
	else if (equalStrings(prop_name, "height"))
		LuaWrapper::push(L, module->getControllerHeight(entity));
	else if (equalStrings(prop_name, "use_custom_gravity"))
		LuaWrapper::push(L, module->getControllerCustomGravity(entity));
	else if (equalStrings(prop_name, "custom_gravity_acceleration"))
		LuaWrapper::push(L, module->getControllerCustomGravityAcceleration(entity));
	else if (equalStrings(prop_name, "use_root_motion"))
		LuaWrapper::push(L, module->getControllerUseRootMotion(entity));
	else if (equalStrings(prop_name, "getGravitySpeed")) {
		lua_pushcfunction(L, Controller_getGravitySpeed, "Controller_getGravitySpeed");
	} else if (equalStrings(prop_name, "move")) {
		lua_pushcfunction(L, Controller_move, "Controller_moveController");
	} else if (equalStrings(prop_name, "isCollisionDown")) {
		lua_pushcfunction(L, Controller_isCollisionDown, "Controller_isControllerCollisionDown");
	} else if (equalStrings(prop_name, "resize")) {
		lua_pushcfunction(L, Controller_resize, "Controller_resizeController");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Controller_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "layer"))
		module->setControllerLayer(entity, LuaWrapper::checkArg<u32>(L, 3));
	else if (equalStrings(prop_name, "radius"))
		module->setControllerRadius(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "height"))
		module->setControllerHeight(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "use_custom_gravity"))
		module->setControllerCustomGravity(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "custom_gravity_acceleration"))
		module->setControllerCustomGravityAcceleration(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "use_root_motion"))
		module->setControllerUseRootMotion(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Actor_putToSleep(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	module->putToSleep(entity);
	return 0;
}

int Actor_addForceAtPos(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	auto force = LuaWrapper::checkArg<Vec3>(L, 2);
	auto pos = LuaWrapper::checkArg<Vec3>(L, 3);
	module->addForceAtPos(entity, force, pos);
	return 0;
}

int Actor_applyForce(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	auto force = LuaWrapper::checkArg<Vec3>(L, 2);
	module->applyForceToActor(entity, force);
	return 0;
}

int Actor_applyImpulse(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	auto force = LuaWrapper::checkArg<Vec3>(L, 2);
	module->applyImpulseToActor(entity, force);
	return 0;
}

int Actor_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "boxes")) {
		using GetterModule = PhysicsModule;
		auto getter = [](lua_State* L) -> int {
			LuaWrapper::checkTableArg(L, 1); // self
			auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
			EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
			if (lua_type(L, 2) == LUA_TSTRING) {
				auto adder = [](lua_State* L) -> int {
					auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
					EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
					module->addBox(entity, module->getBoxCount(entity));
					return 0;
				};

				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				if (equalStrings(prop_name, "add")) {
					LuaWrapper::push(L, module);
					LuaWrapper::push(L, entity.index);
					lua_pushcclosure(L, adder, "adder", 2);
					return 1;
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
			}

			auto getter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "half_extents")) {
					LuaWrapper::push(L, module->getBoxHalfExtents(entity, index));
				} else if (equalStrings(prop_name, "position_offset")) {
					LuaWrapper::push(L, module->getBoxOffsetPosition(entity, index));
				} else if (equalStrings(prop_name, "rotation_offset")) {
					LuaWrapper::push(L, module->getBoxOffsetRotation(entity, index));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
				return 1;
			};

			auto setter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "half_extents")) {
					module->setBoxHalfExtents(entity, index, LuaWrapper::checkArg<Vec3>(L, 3));
				} else if (equalStrings(prop_name, "position_offset")) {
					module->setBoxOffsetPosition(entity, index, LuaWrapper::checkArg<Vec3>(L, 3));
				} else if (equalStrings(prop_name, "rotation_offset")) {
					module->setBoxOffsetRotation(entity, index, LuaWrapper::checkArg<Vec3>(L, 3));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %ss", prop_name);
				}
				return 0;
			};

			i32 index = LuaWrapper::checkArg<i32>(L, 2) - 1;
			i32 num_elements = module->getBoxCount(entity);
			if (index >= num_elements) {
				lua_pushnil(L);
				return 1;
			}

			lua_newtable(L);
			lua_newtable(L);

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, getter, "getter", 3);
			lua_setfield(L, -2, "__index");

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, setter, "setter", 3);
			lua_setfield(L, -2, "__newindex");

			lua_setmetatable(L, -2);
			return 1;
		};

		lua_newtable(L); // {}
		lua_newtable(L); // {}, metatable
		LuaWrapper::push(L, module);
		LuaWrapper::push(L, entity.index);
		lua_pushcclosure(L, getter, "getter", 2);
		lua_setfield(L, -2, "__index"); // {}, mt
		lua_setmetatable(L, -2);		// {}
	} else if (equalStrings(prop_name, "spheres")) {
		using GetterModule = PhysicsModule;
		auto getter = [](lua_State* L) -> int {
			LuaWrapper::checkTableArg(L, 1); // self
			auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
			EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
			if (lua_type(L, 2) == LUA_TSTRING) {
				auto adder = [](lua_State* L) -> int {
					auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
					EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
					module->addSphere(entity, module->getSphereCount(entity));
					return 0;
				};

				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				if (equalStrings(prop_name, "add")) {
					LuaWrapper::push(L, module);
					LuaWrapper::push(L, entity.index);
					lua_pushcclosure(L, adder, "adder", 2);
					return 1;
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
			}

			auto getter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "radius")) {
					LuaWrapper::push(L, module->getSphereRadius(entity, index));
				} else if (equalStrings(prop_name, "position_offset")) {
					LuaWrapper::push(L, module->getSphereOffsetPosition(entity, index));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
				return 1;
			};

			auto setter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "radius")) {
					module->setSphereRadius(entity, index, LuaWrapper::checkArg<float>(L, 3));
				} else if (equalStrings(prop_name, "position_offset")) {
					module->setSphereOffsetPosition(entity, index, LuaWrapper::checkArg<Vec3>(L, 3));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %ss", prop_name);
				}
				return 0;
			};

			i32 index = LuaWrapper::checkArg<i32>(L, 2) - 1;
			i32 num_elements = module->getSphereCount(entity);
			if (index >= num_elements) {
				lua_pushnil(L);
				return 1;
			}

			lua_newtable(L);
			lua_newtable(L);

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, getter, "getter", 3);
			lua_setfield(L, -2, "__index");

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, setter, "setter", 3);
			lua_setfield(L, -2, "__newindex");

			lua_setmetatable(L, -2);
			return 1;
		};

		lua_newtable(L); // {}
		lua_newtable(L); // {}, metatable
		LuaWrapper::push(L, module);
		LuaWrapper::push(L, entity.index);
		lua_pushcclosure(L, getter, "getter", 2);
		lua_setfield(L, -2, "__index"); // {}, mt
		lua_setmetatable(L, -2);		// {}
	} else if (equalStrings(prop_name, "velocity"))
		LuaWrapper::push(L, module->getActorVelocity(entity));
	else if (equalStrings(prop_name, "speed"))
		LuaWrapper::push(L, module->getActorSpeed(entity));
	else if (equalStrings(prop_name, "layer"))
		LuaWrapper::push(L, module->getActorLayer(entity));
	else if (equalStrings(prop_name, "dynamic"))
		LuaWrapper::push(L, (i32)module->getActorDynamicType(entity));
	else if (equalStrings(prop_name, "is_trigger"))
		LuaWrapper::push(L, module->getActorIsTrigger(entity));
	else if (equalStrings(prop_name, "mesh"))
		LuaWrapper::push(L, module->getActorMesh(entity));
	else if (equalStrings(prop_name, "material"))
		LuaWrapper::push(L, module->getActorMaterial(entity));
	else if (equalStrings(prop_name, "ccd"))
		LuaWrapper::push(L, module->getActorCCD(entity));
	else if (equalStrings(prop_name, "putToSleep")) {
		lua_pushcfunction(L, Actor_putToSleep, "Actor_putToSleep");
	} else if (equalStrings(prop_name, "addForceAtPos")) {
		lua_pushcfunction(L, Actor_addForceAtPos, "Actor_addForceAtPos");
	} else if (equalStrings(prop_name, "applyForce")) {
		lua_pushcfunction(L, Actor_applyForce, "Actor_applyForceToActor");
	} else if (equalStrings(prop_name, "applyImpulse")) {
		lua_pushcfunction(L, Actor_applyImpulse, "Actor_applyImpulseToActor");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Actor_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "layer"))
		module->setActorLayer(entity, LuaWrapper::checkArg<u32>(L, 3));
	else if (equalStrings(prop_name, "dynamic"))
		module->setActorDynamicType(entity, (PhysicsModule::DynamicType)LuaWrapper::checkArg<i32>(L, 3));
	else if (equalStrings(prop_name, "is_trigger"))
		module->setActorIsTrigger(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "mesh"))
		module->setActorMesh(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "material"))
		module->setActorMaterial(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "ccd"))
		module->setActorCCD(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Wheel_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "spring_strength"))
		LuaWrapper::push(L, module->getWheelSpringStrength(entity));
	else if (equalStrings(prop_name, "spring_max_compression"))
		LuaWrapper::push(L, module->getWheelSpringMaxCompression(entity));
	else if (equalStrings(prop_name, "spring_max_droop"))
		LuaWrapper::push(L, module->getWheelSpringMaxDroop(entity));
	else if (equalStrings(prop_name, "spring_damper_rate"))
		LuaWrapper::push(L, module->getWheelSpringDamperRate(entity));
	else if (equalStrings(prop_name, "radius"))
		LuaWrapper::push(L, module->getWheelRadius(entity));
	else if (equalStrings(prop_name, "width"))
		LuaWrapper::push(L, module->getWheelWidth(entity));
	else if (equalStrings(prop_name, "mass"))
		LuaWrapper::push(L, module->getWheelMass(entity));
	else if (equalStrings(prop_name, "moi"))
		LuaWrapper::push(L, module->getWheelMOI(entity));
	else if (equalStrings(prop_name, "slot"))
		LuaWrapper::push(L, (i32)module->getWheelSlot(entity));
	else if (equalStrings(prop_name, "rpm"))
		LuaWrapper::push(L, module->getWheelRPM(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Wheel_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "spring_strength"))
		module->setWheelSpringStrength(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "spring_max_compression"))
		module->setWheelSpringMaxCompression(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "spring_max_droop"))
		module->setWheelSpringMaxDroop(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "spring_damper_rate"))
		module->setWheelSpringDamperRate(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "radius"))
		module->setWheelRadius(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "width"))
		module->setWheelWidth(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "mass"))
		module->setWheelMass(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "moi"))
		module->setWheelMOI(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "slot"))
		module->setWheelSlot(entity, (PhysicsModule::WheelSlot)LuaWrapper::checkArg<i32>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Vehicle_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "peak_torque"))
		LuaWrapper::push(L, module->getVehiclePeakTorque(entity));
	else if (equalStrings(prop_name, "max__r_p_m"))
		LuaWrapper::push(L, module->getVehicleMaxRPM(entity));
	else if (equalStrings(prop_name, "rpm"))
		LuaWrapper::push(L, module->getVehicleRPM(entity));
	else if (equalStrings(prop_name, "current_gear"))
		LuaWrapper::push(L, module->getVehicleCurrentGear(entity));
	else if (equalStrings(prop_name, "speed"))
		LuaWrapper::push(L, module->getVehicleSpeed(entity));
	else if (equalStrings(prop_name, "chassis"))
		LuaWrapper::push(L, module->getVehicleChassis(entity));
	else if (equalStrings(prop_name, "mass"))
		LuaWrapper::push(L, module->getVehicleMass(entity));
	else if (equalStrings(prop_name, "moi_multiplier"))
		LuaWrapper::push(L, module->getVehicleMOIMultiplier(entity));
	else if (equalStrings(prop_name, "center_of_mass"))
		LuaWrapper::push(L, module->getVehicleCenterOfMass(entity));
	else if (equalStrings(prop_name, "wheels_layer"))
		LuaWrapper::push(L, module->getVehicleWheelsLayer(entity));
	else if (equalStrings(prop_name, "chassis_layer"))
		LuaWrapper::push(L, module->getVehicleChassisLayer(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Vehicle_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "peak_torque"))
		module->setVehiclePeakTorque(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "max__r_p_m"))
		module->setVehicleMaxRPM(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "chassis"))
		module->setVehicleChassis(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "mass"))
		module->setVehicleMass(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "moi_multiplier"))
		module->setVehicleMOIMultiplier(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "center_of_mass"))
		module->setVehicleCenterOfMass(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "wheels_layer"))
		module->setVehicleWheelsLayer(entity, LuaWrapper::checkArg<u32>(L, 3));
	else if (equalStrings(prop_name, "chassis_layer"))
		module->setVehicleChassisLayer(entity, LuaWrapper::checkArg<u32>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int InstancedCube_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "half_extents"))
		LuaWrapper::push(L, module->getInstancedCubeHalfExtents(entity));
	else if (equalStrings(prop_name, "layer"))
		LuaWrapper::push(L, module->getInstancedCubeLayer(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int InstancedCube_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "half_extents"))
		module->setInstancedCubeHalfExtents(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "layer"))
		module->setInstancedCubeLayer(entity, LuaWrapper::checkArg<u32>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int InstancedMesh_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "layer"))
		LuaWrapper::push(L, module->getInstancedMeshLayer(entity));
	else if (equalStrings(prop_name, "mesh"))
		LuaWrapper::push(L, module->getInstancedMeshGeomPath(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int InstancedMesh_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (PhysicsModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "layer"))
		module->setInstancedMeshLayer(entity, LuaWrapper::checkArg<u32>(L, 3));
	else if (equalStrings(prop_name, "mesh"))
		module->setInstancedMeshGeomPath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {
int RenderModule_castRay(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	Ray ray;

	if (!LuaWrapper::checkField(L, 2, "origin", &ray.origin)) luaL_error(L, "Invalid argument");
	if (!LuaWrapper::checkField(L, 2, "dir", &ray.dir)) luaL_error(L, "Invalid argument");
	auto ignore = LuaWrapper::checkArg<EntityPtr>(L, 3);
	auto s = module->castRay(ray, ignore);
	lua_newtable(L);
	LuaWrapper::push(L, s.is_hit);
	lua_setfield(L, -2, "is_hit");
	LuaWrapper::push(L, s.t);
	lua_setfield(L, -2, "t");
	LuaWrapper::push(L, s.origin);
	lua_setfield(L, -2, "origin");
	LuaWrapper::push(L, s.dir);
	lua_setfield(L, -2, "dir");
	LuaWrapper::push(L, s.mesh);
	lua_setfield(L, -2, "mesh");
	LuaWrapper::push(L, s.entity);
	lua_setfield(L, -2, "entity");
	LuaWrapper::push(L, s.component_type);
	lua_setfield(L, -2, "component_type");
	LuaWrapper::push(L, s.subindex);
	lua_setfield(L, -2, "subindex");
	return 1;
}

int RenderModule_castRayTerrain(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	Ray ray;

	if (!LuaWrapper::checkField(L, 2, "origin", &ray.origin)) luaL_error(L, "Invalid argument");
	if (!LuaWrapper::checkField(L, 2, "dir", &ray.dir)) luaL_error(L, "Invalid argument");
	auto s = module->castRayTerrain(ray);
	lua_newtable(L);
	LuaWrapper::push(L, s.is_hit);
	lua_setfield(L, -2, "is_hit");
	LuaWrapper::push(L, s.t);
	lua_setfield(L, -2, "t");
	LuaWrapper::push(L, s.origin);
	lua_setfield(L, -2, "origin");
	LuaWrapper::push(L, s.dir);
	lua_setfield(L, -2, "dir");
	LuaWrapper::push(L, s.mesh);
	lua_setfield(L, -2, "mesh");
	LuaWrapper::push(L, s.entity);
	lua_setfield(L, -2, "entity");
	LuaWrapper::push(L, s.component_type);
	lua_setfield(L, -2, "component_type");
	LuaWrapper::push(L, s.subindex);
	lua_setfield(L, -2, "subindex");
	return 1;
}

int RenderModule_addDebugTriangle(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto p0 = LuaWrapper::checkArg<DVec3>(L, 2);
	auto p1 = LuaWrapper::checkArg<DVec3>(L, 3);
	auto p2 = LuaWrapper::checkArg<DVec3>(L, 4);
	auto color = LuaWrapper::checkArg<Color>(L, 5);
	module->addDebugTriangle(p0, p1, p2, color);
	return 0;
}

int RenderModule_addDebugLine(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto from = LuaWrapper::checkArg<DVec3>(L, 2);
	auto to = LuaWrapper::checkArg<DVec3>(L, 3);
	auto color = LuaWrapper::checkArg<Color>(L, 4);
	module->addDebugLine(from, to, color);
	return 0;
}

int RenderModule_addDebugCross(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto center = LuaWrapper::checkArg<DVec3>(L, 2);
	auto size = LuaWrapper::checkArg<float>(L, 3);
	auto color = LuaWrapper::checkArg<Color>(L, 4);
	module->addDebugCross(center, size, color);
	return 0;
}

int RenderModule_addDebugBone(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto pos = LuaWrapper::checkArg<DVec3>(L, 2);
	auto dir = LuaWrapper::checkArg<Vec3>(L, 3);
	auto up = LuaWrapper::checkArg<Vec3>(L, 4);
	auto right = LuaWrapper::checkArg<Vec3>(L, 5);
	auto color = LuaWrapper::checkArg<Color>(L, 6);
	module->addDebugBone(pos, dir, up, right, color);
	return 0;
}

int RenderModule_addDebugCube(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto pos = LuaWrapper::checkArg<DVec3>(L, 2);
	auto dir = LuaWrapper::checkArg<Vec3>(L, 3);
	auto up = LuaWrapper::checkArg<Vec3>(L, 4);
	auto right = LuaWrapper::checkArg<Vec3>(L, 5);
	auto color = LuaWrapper::checkArg<Color>(L, 6);
	module->addDebugCube(pos, dir, up, right, color);
	return 0;
}

int RenderModule_addDebugCubeSolid(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto from = LuaWrapper::checkArg<DVec3>(L, 2);
	auto max = LuaWrapper::checkArg<DVec3>(L, 3);
	auto color = LuaWrapper::checkArg<Color>(L, 4);
	module->addDebugCubeSolid(from, max, color);
	return 0;
}

int RenderModule_setActiveCamera(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto camera = LuaWrapper::checkArg<EntityRef>(L, 2);
	module->setActiveCamera(camera);
	return 0;
}

int RenderModule_setActiveEnvironment(lua_State* L) {
	LuaWrapper::checkTableArg(L, 1);
	RenderModule* module;
	if (!LuaWrapper::checkField(L, 1, "_module", &module)) luaL_argerror(L, 1, "Module expected");
	auto entity = LuaWrapper::checkArg<EntityRef>(L, 2);
	module->setActiveEnvironment(entity);
	return 0;
}

int Camera_getRay(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	auto screen_pos = LuaWrapper::checkArg<Vec2>(L, 2);
	auto s = module->getCameraRay(entity, screen_pos);
	lua_newtable(L);
	LuaWrapper::push(L, s.origin);
	lua_setfield(L, -2, "origin");
	LuaWrapper::push(L, s.dir);
	lua_setfield(L, -2, "dir");

	return 1;
}

int Camera_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "fov"))
		LuaWrapper::push(L, module->getCamera(entity).fov);
	else if (equalStrings(prop_name, "near"))
		LuaWrapper::push(L, module->getCamera(entity).near);
	else if (equalStrings(prop_name, "far"))
		LuaWrapper::push(L, module->getCamera(entity).far);
	else if (equalStrings(prop_name, "is_ortho"))
		LuaWrapper::push(L, module->getCamera(entity).is_ortho);
	else if (equalStrings(prop_name, "ortho_size"))
		LuaWrapper::push(L, module->getCamera(entity).ortho_size);
	else if (equalStrings(prop_name, "film_grain_intensity"))
		LuaWrapper::push(L, module->getCamera(entity).film_grain_intensity);
	else if (equalStrings(prop_name, "dof_enabled"))
		LuaWrapper::push(L, module->getCamera(entity).dof_enabled);
	else if (equalStrings(prop_name, "dof_distance"))
		LuaWrapper::push(L, module->getCamera(entity).dof_distance);
	else if (equalStrings(prop_name, "dof_range"))
		LuaWrapper::push(L, module->getCamera(entity).dof_range);
	else if (equalStrings(prop_name, "dof_max_blur_size"))
		LuaWrapper::push(L, module->getCamera(entity).dof_max_blur_size);
	else if (equalStrings(prop_name, "dof_sharp_range"))
		LuaWrapper::push(L, module->getCamera(entity).dof_sharp_range);
	else if (equalStrings(prop_name, "bloom_enabled"))
		LuaWrapper::push(L, module->getCamera(entity).bloom_enabled);
	else if (equalStrings(prop_name, "bloom_tonemap_enabled"))
		LuaWrapper::push(L, module->getCamera(entity).bloom_tonemap_enabled);
	else if (equalStrings(prop_name, "bloom_accomodation_speed"))
		LuaWrapper::push(L, module->getCamera(entity).bloom_accomodation_speed);
	else if (equalStrings(prop_name, "bloom_avg_bloom_multiplier"))
		LuaWrapper::push(L, module->getCamera(entity).bloom_avg_bloom_multiplier);
	else if (equalStrings(prop_name, "bloom_exposure"))
		LuaWrapper::push(L, module->getCamera(entity).bloom_exposure);
	else if (equalStrings(prop_name, "getRay")) {
		lua_pushcfunction(L, Camera_getRay, "Camera_getCameraRay");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Camera_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "fov"))
		module->getCamera(entity).fov = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "near"))
		module->getCamera(entity).near = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "far"))
		module->getCamera(entity).far = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "is_ortho"))
		module->getCamera(entity).is_ortho = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "ortho_size"))
		module->getCamera(entity).ortho_size = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "film_grain_intensity"))
		module->getCamera(entity).film_grain_intensity = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "dof_enabled"))
		module->getCamera(entity).dof_enabled = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "dof_distance"))
		module->getCamera(entity).dof_distance = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "dof_range"))
		module->getCamera(entity).dof_range = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "dof_max_blur_size"))
		module->getCamera(entity).dof_max_blur_size = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "dof_sharp_range"))
		module->getCamera(entity).dof_sharp_range = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "bloom_enabled"))
		module->getCamera(entity).bloom_enabled = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "bloom_tonemap_enabled"))
		module->getCamera(entity).bloom_tonemap_enabled = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "bloom_accomodation_speed"))
		module->getCamera(entity).bloom_accomodation_speed = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "bloom_avg_bloom_multiplier"))
		module->getCamera(entity).bloom_avg_bloom_multiplier = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "bloom_exposure"))
		module->getCamera(entity).bloom_exposure = LuaWrapper::checkArg<float>(L, 3);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Decal_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "uv_scale"))
		LuaWrapper::push(L, module->getDecal(entity).uv_scale);
	else if (equalStrings(prop_name, "material"))
		LuaWrapper::push(L, module->getDecalMaterialPath(entity));
	else if (equalStrings(prop_name, "half_extents"))
		LuaWrapper::push(L, module->getDecalHalfExtents(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Decal_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "uv_scale"))
		module->getDecal(entity).uv_scale = LuaWrapper::checkArg<Vec2>(L, 3);
	else if (equalStrings(prop_name, "material"))
		module->setDecalMaterialPath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "half_extents"))
		module->setDecalHalfExtents(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Environment_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "light_color"))
		LuaWrapper::push(L, module->getEnvironment(entity).light_color);
	else if (equalStrings(prop_name, "direct_intensity"))
		LuaWrapper::push(L, module->getEnvironment(entity).direct_intensity);
	else if (equalStrings(prop_name, "indirect_intensity"))
		LuaWrapper::push(L, module->getEnvironment(entity).indirect_intensity);
	else if (equalStrings(prop_name, "sky_intensity"))
		LuaWrapper::push(L, module->getEnvironment(entity).sky_intensity);
	else if (equalStrings(prop_name, "scatter_rayleigh"))
		LuaWrapper::push(L, module->getEnvironment(entity).scatter_rayleigh);
	else if (equalStrings(prop_name, "scatter_mie"))
		LuaWrapper::push(L, module->getEnvironment(entity).scatter_mie);
	else if (equalStrings(prop_name, "absorb_mie"))
		LuaWrapper::push(L, module->getEnvironment(entity).absorb_mie);
	else if (equalStrings(prop_name, "sunlight_color"))
		LuaWrapper::push(L, module->getEnvironment(entity).sunlight_color);
	else if (equalStrings(prop_name, "fog_scattering"))
		LuaWrapper::push(L, module->getEnvironment(entity).fog_scattering);
	else if (equalStrings(prop_name, "fog_density"))
		LuaWrapper::push(L, module->getEnvironment(entity).fog_density);
	else if (equalStrings(prop_name, "sunlight_strength"))
		LuaWrapper::push(L, module->getEnvironment(entity).sunlight_strength);
	else if (equalStrings(prop_name, "height_distribution_rayleigh"))
		LuaWrapper::push(L, module->getEnvironment(entity).height_distribution_rayleigh);
	else if (equalStrings(prop_name, "height_distribution_mie"))
		LuaWrapper::push(L, module->getEnvironment(entity).height_distribution_mie);
	else if (equalStrings(prop_name, "ground_r"))
		LuaWrapper::push(L, module->getEnvironment(entity).ground_r);
	else if (equalStrings(prop_name, "atmo_r"))
		LuaWrapper::push(L, module->getEnvironment(entity).atmo_r);
	else if (equalStrings(prop_name, "fog_top"))
		LuaWrapper::push(L, module->getEnvironment(entity).fog_top);
	else if (equalStrings(prop_name, "godrays_enabled"))
		LuaWrapper::push(L, module->getEnvironment(entity).godrays_enabled);
	else if (equalStrings(prop_name, "atmo_enabled"))
		LuaWrapper::push(L, module->getEnvironment(entity).atmo_enabled);
	else if (equalStrings(prop_name, "clouds_enabled"))
		LuaWrapper::push(L, module->getEnvironment(entity).clouds_enabled);
	else if (equalStrings(prop_name, "clouds_top"))
		LuaWrapper::push(L, module->getEnvironment(entity).clouds_top);
	else if (equalStrings(prop_name, "clouds_bottom"))
		LuaWrapper::push(L, module->getEnvironment(entity).clouds_bottom);
	else if (equalStrings(prop_name, "cast_shadows"))
		LuaWrapper::push(L, module->getEnvironmentCastShadows(entity));
	else if (equalStrings(prop_name, "sky_texture"))
		LuaWrapper::push(L, module->getEnvironmentSkyTexture(entity));
	else if (equalStrings(prop_name, "shadowmap_cascades"))
		LuaWrapper::push(L, module->getEnvironmentShadowmapCascades(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Environment_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "light_color"))
		module->getEnvironment(entity).light_color = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "direct_intensity"))
		module->getEnvironment(entity).direct_intensity = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "indirect_intensity"))
		module->getEnvironment(entity).indirect_intensity = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "sky_intensity"))
		module->getEnvironment(entity).sky_intensity = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "scatter_rayleigh"))
		module->getEnvironment(entity).scatter_rayleigh = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "scatter_mie"))
		module->getEnvironment(entity).scatter_mie = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "absorb_mie"))
		module->getEnvironment(entity).absorb_mie = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "sunlight_color"))
		module->getEnvironment(entity).sunlight_color = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "fog_scattering"))
		module->getEnvironment(entity).fog_scattering = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "fog_density"))
		module->getEnvironment(entity).fog_density = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "sunlight_strength"))
		module->getEnvironment(entity).sunlight_strength = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "height_distribution_rayleigh"))
		module->getEnvironment(entity).height_distribution_rayleigh = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "height_distribution_mie"))
		module->getEnvironment(entity).height_distribution_mie = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "ground_r"))
		module->getEnvironment(entity).ground_r = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "atmo_r"))
		module->getEnvironment(entity).atmo_r = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "fog_top"))
		module->getEnvironment(entity).fog_top = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "godrays_enabled"))
		module->getEnvironment(entity).godrays_enabled = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "atmo_enabled"))
		module->getEnvironment(entity).atmo_enabled = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "clouds_enabled"))
		module->getEnvironment(entity).clouds_enabled = LuaWrapper::checkArg<bool>(L, 3);
	else if (equalStrings(prop_name, "clouds_top"))
		module->getEnvironment(entity).clouds_top = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "clouds_bottom"))
		module->getEnvironment(entity).clouds_bottom = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "cast_shadows"))
		module->setEnvironmentCastShadows(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "sky_texture"))
		module->setEnvironmentSkyTexture(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "shadowmap_cascades"))
		module->setEnvironmentShadowmapCascades(entity, LuaWrapper::checkArg<Vec4>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int PointLight_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "color"))
		LuaWrapper::push(L, module->getPointLight(entity).color);
	else if (equalStrings(prop_name, "intensity"))
		LuaWrapper::push(L, module->getPointLight(entity).intensity);
	else if (equalStrings(prop_name, "fov"))
		LuaWrapper::push(L, module->getPointLight(entity).fov);
	else if (equalStrings(prop_name, "attenuation_param"))
		LuaWrapper::push(L, module->getPointLight(entity).attenuation_param);
	else if (equalStrings(prop_name, "range"))
		LuaWrapper::push(L, module->getPointLightRange(entity));
	else if (equalStrings(prop_name, "cast_shadows"))
		LuaWrapper::push(L, module->getPointLightCastShadows(entity));
	else if (equalStrings(prop_name, "dynamic"))
		LuaWrapper::push(L, module->getPointLightDynamic(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int PointLight_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "color"))
		module->getPointLight(entity).color = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "intensity"))
		module->getPointLight(entity).intensity = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "fov"))
		module->getPointLight(entity).fov = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "attenuation_param"))
		module->getPointLight(entity).attenuation_param = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "range"))
		module->setPointLightRange(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "cast_shadows"))
		module->setPointLightCastShadows(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "dynamic"))
		module->setPointLightDynamic(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int ReflectionProbe_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "size"))
		LuaWrapper::push(L, module->getReflectionProbe(entity).size);
	else if (equalStrings(prop_name, "half_extents"))
		LuaWrapper::push(L, module->getReflectionProbe(entity).half_extents);
	else if (equalStrings(prop_name, "enabled"))
		LuaWrapper::push(L, module->isReflectionProbeEnabled(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int ReflectionProbe_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "size"))
		module->getReflectionProbe(entity).size = LuaWrapper::checkArg<u32>(L, 3);
	else if (equalStrings(prop_name, "half_extents"))
		module->getReflectionProbe(entity).half_extents = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "enabled"))
		module->enableReflectionProbe(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int EnvironmentProbe_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "inner_range"))
		LuaWrapper::push(L, module->getEnvironmentProbe(entity).inner_range);
	else if (equalStrings(prop_name, "outer_range"))
		LuaWrapper::push(L, module->getEnvironmentProbe(entity).outer_range);
	else if (equalStrings(prop_name, "enabled"))
		LuaWrapper::push(L, module->isEnvironmentProbeEnabled(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int EnvironmentProbe_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "inner_range"))
		module->getEnvironmentProbe(entity).inner_range = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "outer_range"))
		module->getEnvironmentProbe(entity).outer_range = LuaWrapper::checkArg<Vec3>(L, 3);
	else if (equalStrings(prop_name, "enabled"))
		module->enableEnvironmentProbe(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Fur_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "layers"))
		LuaWrapper::push(L, module->getFur(entity).layers);
	else if (equalStrings(prop_name, "scale"))
		LuaWrapper::push(L, module->getFur(entity).scale);
	else if (equalStrings(prop_name, "gravity"))
		LuaWrapper::push(L, module->getFur(entity).gravity);
	else if (equalStrings(prop_name, "enabled"))
		LuaWrapper::push(L, module->getFur(entity).enabled);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Fur_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "layers"))
		module->getFur(entity).layers = LuaWrapper::checkArg<u32>(L, 3);
	else if (equalStrings(prop_name, "scale"))
		module->getFur(entity).scale = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "gravity"))
		module->getFur(entity).gravity = LuaWrapper::checkArg<float>(L, 3);
	else if (equalStrings(prop_name, "enabled"))
		module->getFur(entity).enabled = LuaWrapper::checkArg<bool>(L, 3);
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int BoneAttachment_setRotation(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	auto rot = LuaWrapper::checkArg<Quat>(L, 2);
	module->setBoneAttachmentRotationQuat(entity, rot);
	return 0;
}

int BoneAttachment_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "parent"))
		LuaWrapper::push(L, module->getBoneAttachmentParent(entity));
	else if (equalStrings(prop_name, "bone"))
		LuaWrapper::push(L, module->getBoneAttachmentBone(entity));
	else if (equalStrings(prop_name, "relative_position"))
		LuaWrapper::push(L, module->getBoneAttachmentPosition(entity));
	else if (equalStrings(prop_name, "relative_rotation"))
		LuaWrapper::push(L, module->getBoneAttachmentRotation(entity));
	else if (equalStrings(prop_name, "setRotation")) {
		lua_pushcfunction(L, BoneAttachment_setRotation, "BoneAttachment_setBoneAttachmentRotationQuat");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int BoneAttachment_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "parent"))
		module->setBoneAttachmentParent(entity, LuaWrapper::checkArg<EntityPtr>(L, 3));
	else if (equalStrings(prop_name, "bone"))
		module->setBoneAttachmentBone(entity, LuaWrapper::checkArg<int>(L, 3));
	else if (equalStrings(prop_name, "relative_position"))
		module->setBoneAttachmentPosition(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else if (equalStrings(prop_name, "relative_rotation"))
		module->setBoneAttachmentRotation(entity, LuaWrapper::checkArg<Vec3>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int ParticleSystem_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "source"))
		LuaWrapper::push(L, module->getParticleSystemPath(entity));
	else if (equalStrings(prop_name, "autodestroy"))
		LuaWrapper::push(L, module->getParticleSystemAutodestroy(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int ParticleSystem_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "source"))
		module->setParticleSystemPath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "autodestroy"))
		module->setParticleSystemAutodestroy(entity, LuaWrapper::checkArg<bool>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int InstancedModel_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "model"))
		LuaWrapper::push(L, module->getInstancedModelPath(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int InstancedModel_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "model"))
		module->setInstancedModelPath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int ModelInstance_overrideMaterialVec4(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	auto mesh_index = LuaWrapper::checkArg<u32>(L, 2);
	auto uniform_name = LuaWrapper::checkArg<const char*>(L, 3);
	auto value = LuaWrapper::checkArg<Vec4>(L, 4);
	LuaWrapper::push(L, module->overrideMaterialVec4(entity, mesh_index, uniform_name, value));
	return 1;
}

int ModelInstance_getModel(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	LuaWrapper::push(L, module->getModelInstanceModel(entity));
	return 1;
}

int ModelInstance_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		LuaWrapper::push(L, module->isModelInstanceEnabled(entity));
	else if (equalStrings(prop_name, "source"))
		LuaWrapper::push(L, module->getModelInstancePath(entity));
	else if (equalStrings(prop_name, "overrideMaterialVec4")) {
		lua_pushcfunction(L, ModelInstance_overrideMaterialVec4, "ModelInstance_overrideMaterialVec4");
	} else if (equalStrings(prop_name, "getModel")) {
		lua_pushcfunction(L, ModelInstance_getModel, "ModelInstance_getModelInstanceModel");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int ModelInstance_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "enabled"))
		module->enableModelInstance(entity, LuaWrapper::checkArg<bool>(L, 3));
	else if (equalStrings(prop_name, "source"))
		module->setModelInstancePath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int CurveDecal_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "material"))
		LuaWrapper::push(L, module->getCurveDecalMaterialPath(entity));
	else if (equalStrings(prop_name, "half_extents"))
		LuaWrapper::push(L, module->getCurveDecalHalfExtents(entity));
	else if (equalStrings(prop_name, "uv_scale"))
		LuaWrapper::push(L, module->getCurveDecalUVScale(entity));
	else if (equalStrings(prop_name, "bezier_p0"))
		LuaWrapper::push(L, module->getCurveDecalBezierP0(entity));
	else if (equalStrings(prop_name, "bezier_p2"))
		LuaWrapper::push(L, module->getCurveDecalBezierP2(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int CurveDecal_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "material"))
		module->setCurveDecalMaterialPath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "half_extents"))
		module->setCurveDecalHalfExtents(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "uv_scale"))
		module->setCurveDecalUVScale(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else if (equalStrings(prop_name, "bezier_p0"))
		module->setCurveDecalBezierP0(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else if (equalStrings(prop_name, "bezier_p2"))
		module->setCurveDecalBezierP2(entity, LuaWrapper::checkArg<Vec2>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int Terrain_getHeightAt(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	auto x = LuaWrapper::checkArg<float>(L, 2);
	auto z = LuaWrapper::checkArg<float>(L, 3);
	LuaWrapper::push(L, module->getTerrainHeightAt(entity, x, z));
	return 1;
}

int Terrain_getNormalAt(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	auto x = LuaWrapper::checkArg<float>(L, 2);
	auto z = LuaWrapper::checkArg<float>(L, 3);
	LuaWrapper::push(L, module->getTerrainNormalAt(entity, x, z));
	return 1;
}

int Terrain_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "grass")) {
		using GetterModule = RenderModule;
		auto getter = [](lua_State* L) -> int {
			LuaWrapper::checkTableArg(L, 1); // self
			auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
			EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
			if (lua_type(L, 2) == LUA_TSTRING) {
				auto adder = [](lua_State* L) -> int {
					auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
					EntityRef entity{LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
					module->addGrass(entity, module->getGrassCount(entity));
					return 0;
				};

				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				if (equalStrings(prop_name, "add")) {
					LuaWrapper::push(L, module);
					LuaWrapper::push(L, entity.index);
					lua_pushcclosure(L, adder, "adder", 2);
					return 1;
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
			}

			auto getter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "rotation_mode")) {
					LuaWrapper::push(L, (i32)module->getGrassRotationMode(entity, index));
				} else if (equalStrings(prop_name, "distance")) {
					LuaWrapper::push(L, module->getGrassDistance(entity, index));
				} else if (equalStrings(prop_name, "mesh")) {
					LuaWrapper::push(L, module->getGrassPath(entity, index));
				} else if (equalStrings(prop_name, "spacing")) {
					LuaWrapper::push(L, module->getGrassSpacing(entity, index));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %s", prop_name);
				}
				return 1;
			};

			auto setter = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1);
				const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
				auto* module = LuaWrapper::toType<GetterModule*>(L, lua_upvalueindex(1));
				EntityRef entity = {LuaWrapper::toType<i32>(L, lua_upvalueindex(2))};
				i32 index = LuaWrapper::toType<int>(L, lua_upvalueindex(3));
				if (false) {
				} else if (equalStrings(prop_name, "rotation_mode")) {
					module->setGrassRotationMode(entity, index, (GrassRotationMode)LuaWrapper::checkArg<i32>(L, 3));
				} else if (equalStrings(prop_name, "distance")) {
					module->setGrassDistance(entity, index, LuaWrapper::checkArg<float>(L, 3));
				} else if (equalStrings(prop_name, "mesh")) {
					module->setGrassPath(entity, index, LuaWrapper::checkArg<Path>(L, 3));
				} else if (equalStrings(prop_name, "spacing")) {
					module->setGrassSpacing(entity, index, LuaWrapper::checkArg<float>(L, 3));
				} else {
					ASSERT(false);
					luaL_error(L, "Unknown property %ss", prop_name);
				}
				return 0;
			};

			i32 index = LuaWrapper::checkArg<i32>(L, 2) - 1;
			i32 num_elements = module->getGrassCount(entity);
			if (index >= num_elements) {
				lua_pushnil(L);
				return 1;
			}

			lua_newtable(L);
			lua_newtable(L);

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, getter, "getter", 3);
			lua_setfield(L, -2, "__index");

			lua_pushlightuserdata(L, (void*)module);
			LuaWrapper::push(L, entity.index);
			LuaWrapper::push(L, index);
			lua_pushcclosure(L, setter, "setter", 3);
			lua_setfield(L, -2, "__newindex");

			lua_setmetatable(L, -2);
			return 1;
		};

		lua_newtable(L); // {}
		lua_newtable(L); // {}, metatable
		LuaWrapper::push(L, module);
		LuaWrapper::push(L, entity.index);
		lua_pushcclosure(L, getter, "getter", 2);
		lua_setfield(L, -2, "__index"); // {}, mt
		lua_setmetatable(L, -2);		// {}
	} else if (equalStrings(prop_name, "size"))
		LuaWrapper::push(L, module->getTerrainSize(entity));
	else if (equalStrings(prop_name, "material"))
		LuaWrapper::push(L, module->getTerrainMaterialPath(entity));
	else if (equalStrings(prop_name, "xz_scale"))
		LuaWrapper::push(L, module->getTerrainXZScale(entity));
	else if (equalStrings(prop_name, "tesselation"))
		LuaWrapper::push(L, module->getTerrainTesselation(entity));
	else if (equalStrings(prop_name, "base_grid_resolution"))
		LuaWrapper::push(L, module->getTerrainBaseGridResolution(entity));
	else if (equalStrings(prop_name, "yscale"))
		LuaWrapper::push(L, module->getTerrainYScale(entity));
	else if (equalStrings(prop_name, "getHeightAt")) {
		lua_pushcfunction(L, Terrain_getHeightAt, "Terrain_getTerrainHeightAt");
	} else if (equalStrings(prop_name, "getNormalAt")) {
		lua_pushcfunction(L, Terrain_getNormalAt, "Terrain_getTerrainNormalAt");
	} else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int Terrain_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "material"))
		module->setTerrainMaterialPath(entity, LuaWrapper::checkArg<Path>(L, 3));
	else if (equalStrings(prop_name, "xz_scale"))
		module->setTerrainXZScale(entity, LuaWrapper::checkArg<float>(L, 3));
	else if (equalStrings(prop_name, "tesselation"))
		module->setTerrainTesselation(entity, LuaWrapper::checkArg<u32>(L, 3));
	else if (equalStrings(prop_name, "base_grid_resolution"))
		module->setTerrainBaseGridResolution(entity, LuaWrapper::checkArg<u32>(L, 3));
	else if (equalStrings(prop_name, "yscale"))
		module->setTerrainYScale(entity, LuaWrapper::checkArg<float>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

int ProceduralGeometry_getter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "material"))
		LuaWrapper::push(L, module->getProceduralGeometryMaterial(entity));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 1;
}

int ProceduralGeometry_setter(lua_State* L) {
	auto [imodule, entity] = checkComponent(L);
	auto* module = (RenderModule*)imodule;
	const char* prop_name = LuaWrapper::checkArg<const char*>(L, 2);
	if (false) {
	} else if (equalStrings(prop_name, "material"))
		module->setProceduralGeometryMaterial(entity, LuaWrapper::checkArg<Path>(L, 3));
	else {
		ASSERT(false);
		luaL_error(L, "Unknown property %s", prop_name);
	}
	return 0;
}

} // namespace Lumix

namespace Lumix {

void registerLuaAPI(lua_State* L) {
	lua_newtable(L);
	lua_setglobal(L, "LumixModules");
	{
		lua_newtable(L);
		lua_getglobal(L, "LumixModules");
		lua_pushvalue(L, -2);
		lua_setfield(L, -2, "audio");
		lua_pop(L, 1);
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
		lua_pushcfunction(L, lua_new_module, "new");
		lua_setfield(L, -2, "new");
		lua_pushcfunction(L, AudioModule_play, "play");
		lua_setfield(L, -2, "play");
		lua_pushcfunction(L, AudioModule_setMasterVolume, "setMasterVolume");
		lua_setfield(L, -2, "setMasterVolume");
		lua_pushcfunction(L, AudioModule_stop, "stop");
		lua_setfield(L, -2, "stop");
		lua_pushcfunction(L, AudioModule_isEnd, "isEnd");
		lua_setfield(L, -2, "isEnd");
		lua_pushcfunction(L, AudioModule_setFrequency, "setFrequency");
		lua_setfield(L, -2, "setFrequency");
		lua_pushcfunction(L, AudioModule_setVolume, "setVolume");
		lua_setfield(L, -2, "setVolume");
		lua_pushcfunction(L, AudioModule_setEcho, "setEcho");
		lua_setfield(L, -2, "setEcho");
		lua_pop(L, 1);
	}
	{
		lua_newtable(L);
		lua_getglobal(L, "LumixModules");
		lua_pushvalue(L, -2);
		lua_setfield(L, -2, "gui");
		lua_pop(L, 1);
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
		lua_pushcfunction(L, lua_new_module, "new");
		lua_setfield(L, -2, "new");
		lua_pushcfunction(L, GUIModule_getRectAt, "getRectAt");
		lua_setfield(L, -2, "getRectAt");
		lua_pushcfunction(L, GUIModule_isOver, "isOver");
		lua_setfield(L, -2, "isOver");
		lua_pushcfunction(L, GUIModule_getSystemPtr, "getSystemPtr");
		lua_setfield(L, -2, "getSystem");
		lua_pop(L, 1);
	}
	{
		lua_newtable(L);
		lua_getglobal(L, "LumixModules");
		lua_pushvalue(L, -2);
		lua_setfield(L, -2, "physics");
		lua_pop(L, 1);
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
		lua_pushcfunction(L, lua_new_module, "new");
		lua_setfield(L, -2, "new");
		lua_pushcfunction(L, PhysicsModule_raycast, "raycast");
		lua_setfield(L, -2, "raycast");
		lua_pushcfunction(L, PhysicsModule_setGravity, "setGravity");
		lua_setfield(L, -2, "setGravity");
		lua_pop(L, 1);
	}
	{
		lua_newtable(L);
		lua_getglobal(L, "LumixModules");
		lua_pushvalue(L, -2);
		lua_setfield(L, -2, "renderer");
		lua_pop(L, 1);
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
		lua_pushcfunction(L, lua_new_module, "new");
		lua_setfield(L, -2, "new");
		lua_pushcfunction(L, RenderModule_castRay, "castRay");
		lua_setfield(L, -2, "castRay");
		lua_pushcfunction(L, RenderModule_castRayTerrain, "castRayTerrain");
		lua_setfield(L, -2, "castRayTerrain");
		lua_pushcfunction(L, RenderModule_addDebugTriangle, "addDebugTriangle");
		lua_setfield(L, -2, "addDebugTriangle");
		lua_pushcfunction(L, RenderModule_addDebugLine, "addDebugLine");
		lua_setfield(L, -2, "addDebugLine");
		lua_pushcfunction(L, RenderModule_addDebugCross, "addDebugCross");
		lua_setfield(L, -2, "addDebugCross");
		lua_pushcfunction(L, RenderModule_addDebugBone, "addDebugBone");
		lua_setfield(L, -2, "addDebugBone");
		lua_pushcfunction(L, RenderModule_addDebugCube, "addDebugCube");
		lua_setfield(L, -2, "addDebugCube");
		lua_pushcfunction(L, RenderModule_addDebugCubeSolid, "addDebugCubeSolid");
		lua_setfield(L, -2, "addDebugCubeSolid");
		lua_pushcfunction(L, RenderModule_setActiveCamera, "setActiveCamera");
		lua_setfield(L, -2, "setActiveCamera");
		lua_pushcfunction(L, RenderModule_setActiveEnvironment, "setActiveEnvironment");
		lua_setfield(L, -2, "setActiveEnvironment");
		lua_pop(L, 1);
	}
	{
		lua_getglobal(L, "LumixAPI");
		lua_newtable(L);
		lua_pushvalue(L, -1);
		lua_setfield(L, -3, "AssetBrowser");
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
		{
			auto proxy = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1); // self
				AssetBrowser* obj;
				if (!LuaWrapper::checkField(L, 1, "_value", &obj)) luaL_error(L, "Invalid object");
				auto resource = LuaWrapper::checkArg<Path>(L, 2);
				obj->openEditor(resource);
				return 0;
			};
			const char* name = "openEditor";
			lua_pushcfunction(L, proxy, name);
			lua_setfield(L, -2, name);
		}
		lua_pop(L, 2);
	}
	{
		lua_getglobal(L, "LumixAPI");
		lua_newtable(L);
		lua_pushvalue(L, -1);
		lua_setfield(L, -3, "GUISystem");
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
		{
			auto proxy = [](lua_State* L) -> int {
				LuaWrapper::checkTableArg(L, 1); // self
				GUISystem* obj;
				if (!LuaWrapper::checkField(L, 1, "_value", &obj)) luaL_error(L, "Invalid object");
				auto enable = LuaWrapper::checkArg<bool>(L, 2);
				obj->enableCursor(enable);
				return 0;
			};
			const char* name = "enableCursor";
			lua_pushcfunction(L, proxy, name);
			lua_setfield(L, -2, name);
		}
		lua_pop(L, 2);
	}
	{
		lua_getglobal(L, "LumixAPI");
		lua_newtable(L);
		lua_pushvalue(L, -1);
		lua_setfield(L, -3, "SceneView");
		lua_pushvalue(L, -1);
		lua_setfield(L, -2, "__index");
		lua_pop(L, 2);
	}
	registerLuaComponent(L, "property_animator", PropertyAnimator_getter, PropertyAnimator_setter);
	registerLuaComponent(L, "animator", Animator_getter, Animator_setter);
	registerLuaComponent(L, "animable", Animable_getter, Animable_setter);
	registerLuaComponent(L, "echo_zone", EchoZone_getter, EchoZone_setter);
	registerLuaComponent(L, "chorus_zone", ChorusZone_getter, ChorusZone_setter);
	registerLuaComponent(L, "audio_listener", Listener_getter, Listener_setter);
	registerLuaComponent(L, "ambient_sound", AmbientSound_getter, AmbientSound_setter);
	registerLuaComponent(L, "spline", Spline_getter, Spline_setter);
	registerLuaComponent(L, "signal", Signal_getter, Signal_setter);
	registerLuaComponent(L, "gui_canvas", Canvas_getter, Canvas_setter);
	registerLuaComponent(L, "gui_render_target", RenderTarget_getter, RenderTarget_setter);
	registerLuaComponent(L, "gui_input_field", InputField_getter, InputField_setter);
	registerLuaComponent(L, "gui_rect", Rect_getter, Rect_setter);
	registerLuaComponent(L, "gui_button", Button_getter, Button_setter);
	registerLuaComponent(L, "gui_image", Image_getter, Image_setter);
	registerLuaComponent(L, "gui_text", Text_getter, Text_setter);
	registerLuaComponent(L, "lua_script", Script_getter, Script_setter);
	registerLuaComponent(L, "lua_script_inline", InlineScript_getter, InlineScript_setter);
	registerLuaComponent(L, "navmesh_zone", Zone_getter, Zone_setter);
	registerLuaComponent(L, "navmesh_agent", Agent_getter, Agent_setter);
	registerLuaComponent(L, "physical_heightfield", Heightfield_getter, Heightfield_setter);
	registerLuaComponent(L, "d6_joint", D6Joint_getter, D6Joint_setter);
	registerLuaComponent(L, "distance_joint", DistanceJoint_getter, DistanceJoint_setter);
	registerLuaComponent(L, "hinge_joint", HingeJoint_getter, HingeJoint_setter);
	registerLuaComponent(L, "spherical_joint", SphericalJoint_getter, SphericalJoint_setter);
	registerLuaComponent(L, "physical_controller", Controller_getter, Controller_setter);
	registerLuaComponent(L, "rigid_actor", Actor_getter, Actor_setter);
	registerLuaComponent(L, "wheel", Wheel_getter, Wheel_setter);
	registerLuaComponent(L, "vehicle", Vehicle_getter, Vehicle_setter);
	registerLuaComponent(L, "physical_instanced_cube", InstancedCube_getter, InstancedCube_setter);
	registerLuaComponent(L, "physical_instanced_mesh", InstancedMesh_getter, InstancedMesh_setter);
	registerLuaComponent(L, "camera", Camera_getter, Camera_setter);
	registerLuaComponent(L, "decal", Decal_getter, Decal_setter);
	registerLuaComponent(L, "environment", Environment_getter, Environment_setter);
	registerLuaComponent(L, "point_light", PointLight_getter, PointLight_setter);
	registerLuaComponent(L, "reflection_probe", ReflectionProbe_getter, ReflectionProbe_setter);
	registerLuaComponent(L, "environment_probe", EnvironmentProbe_getter, EnvironmentProbe_setter);
	registerLuaComponent(L, "fur", Fur_getter, Fur_setter);
	registerLuaComponent(L, "bone_attachment", BoneAttachment_getter, BoneAttachment_setter);
	registerLuaComponent(L, "particle_emitter", ParticleSystem_getter, ParticleSystem_setter);
	registerLuaComponent(L, "instanced_model", InstancedModel_getter, InstancedModel_setter);
	registerLuaComponent(L, "model_instance", ModelInstance_getter, ModelInstance_setter);
	registerLuaComponent(L, "curve_decal", CurveDecal_getter, CurveDecal_setter);
	registerLuaComponent(L, "terrain", Terrain_getter, Terrain_setter);
	registerLuaComponent(L, "procedural_geom", ProceduralGeometry_getter, ProceduralGeometry_setter);
}
} // namespace Lumix
